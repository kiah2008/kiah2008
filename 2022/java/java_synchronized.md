## 前言

首先，synchronized 是什么？我们需要明确的给个定义——**同步锁**，没错，它就是把**锁**。

可以用来干嘛？锁，当然当然是用于线程间的同步，以及保护临界区内的资源。我们知道，锁是个非常笼统的概念，像生活中有指纹锁、密码锁等等多个种类，那 synchronized 代表的锁具体是把什么锁呢？

答案是—— **Java 内置锁**。在 Java 中，每个**对象中**都隐藏着一把锁，而 synchronized 关键字就是激活这把隐式锁的把手（开关）。

先来简单了解一下 synchronized，我们知道其共有 **3 种**使用方式：

![Synchronized 的使用](java_synchronized.assets/e6c9d24egy1gzwxe73v5yj20g5060t8s.jpg)

- 修饰静态方法：锁住当前 class，作用于该 class 的所有实例
- 修饰非静态方法：只会锁住当前 class 的实例
- 修饰代码块：该方法接受一个对象作为参数，锁住的即该对象

使用方法就不在这里赘述，可自行搜索其详细的用法，这不是本篇文章所关心的内容。

知道了 synchronized 的概念，回头来看标题，它说的**锁升级**到底是个啥？对于不太熟悉锁升级的人来说，可能会想：

> 所谓锁，不就是啪一下锁上就完事了吗？升级是个什么玩意？~~这跟打扑克牌也没关系啊。~~

对于熟悉的人来说，可能会想：

> 不就是「无锁 ==> 偏向锁 ==> 轻量级锁 ==> 重量级锁 」吗？

你可能在很多地方看到过上面描述的锁升级过程，也能直接背下来。但你真的知道**无锁**、**偏向锁**、**轻量级锁**、**重量级锁**到底代表着什么吗？这些锁存储在哪里？以及什么情况下会使得锁向下一个 level 升级？

想知道答案，我们似乎必须先搞清楚 Java 内置锁，其内部结构是啥样的？内置锁又存放在哪里？

答案在开篇提到过——在 **Java 对象**中。

那么现在的问题就从「内置锁结构是啥」变成了「Java 对象长啥样」。

## 对象结构

从**宏观**上看，Java 对象的结构很简单，分为三部分：

![Java 对象结构](java_synchronized.assets/e6c9d24egy1gzwxf4af9sj20df060q2x.jpg)

从**微观**上看，各个部分都还可以深入展开，详见下图：

![Java 详细对象结构](java_synchronized.assets/e6c9d24egy1gzwxqscsdsj20j608lglv.jpg)

接下来分别深入讨论一下这三部分。

### **对象头**

从脑图中可以看出，其由 Mark Word、Class Pointer、数组长度三个字段组成。简单来说：

- **Mark Word**：主要用于存储自身运行时数据
- **Class Pointer**：是指针，指向方法区中该 class 的对象，JVM 通过此字段来判断当前对象是哪个类的实例
- **数组长度**：当且仅当对象是数组时才会有该字段

Class Pointer 和数组长度没什么好说的，接下来重点聊聊 Mark Word。

Mark Word 所代表的「运行时数据」主要用来表示当前 Java 对象的线程锁状态以及 GC 的标志。而**线程锁状态**分别就是无锁、偏向锁、轻量级锁、重量级锁。

所以前文提到的这 4 个状态，其实就是 Java 内置锁的**不同状态**。

在 JDK 1.6 之前，内置锁都是**重量级锁**，效率低下。效率低下表现在

而在 JDK 1.6 之后为了提高 synchronized 的效率，才引入了**偏向锁**、**轻量级锁**。

随着锁竞争逐渐激烈，其状态会按照「无锁 ==> 偏向锁 ==> 轻量级锁 ==> 重量级锁 」这个方向逐渐升级，并且**不可逆**，只能进行锁升级，而**无法进行锁降级**。

接下来我们思考一个问题，既然 Mark Word 可以表示 4 种不同的锁状态，其内部到底是怎么区分的呢？（由于目前主流的 JVM 都是 64 位，所以我们只讨论 64 位的 Mark Word）接下来我们通过图片直观的感受一下。

#### （1）无锁

![无锁](java_synchronized.assets/e6c9d24egy1gzxn0ibmq5j20p3069glu.jpg)

这个可以理解为单线程很快乐的运行，没有其他的线程来和其竞争。

#### （2）偏向锁

![偏向锁](java_synchronized.assets/e6c9d24egy1h013co15ozj20q5068t8x.jpg)

首先，什么叫偏向锁？举个例子，一段同步的代码，一直只被线程 A 访问，既然没有其他的线程来竞争，每次都要获取锁岂不是浪费资源？所以这种情况下线程 A 就会自动进入偏向锁的状态。

后续线程 A 再次访问同步代码时，不需要做任何的 check，直接执行（对该线程的「偏爱」），这样降低了获取锁的代价，提升了效率。

看到这里，你会发现无锁、偏向锁的 **lock** 标志位是一样的，即都是 **01**，这是因为无锁、偏向锁是靠字段 **biased_lock** 来区分的，0 代表没有使用偏向锁，1 代表启用了偏向锁。为什么要这么搞？你可以理解为无锁、偏向锁在本质上都可以理解为无锁（参考上面提到的线程 A 的状态），所以 lock 的标志位都是 01 是没毛病的。

> PS：这里的线程 ID 是持有当前对象偏向锁的线程

#### （3）轻量级锁

![轻量级锁](java_synchronized.assets/e6c9d24egy1h012u8h6ooj20p306aglp.jpg)

但是，一旦有第二个线程参与竞争，就会立即膨胀为**轻量级锁**。企图抢占的线程一开始会使用**自旋**：

![img](java_synchronized.assets/e6c9d24egy1h016chjpyrj207s08laa5.jpg)

的方式去**尝试获取锁**。如果循环几次，其他的线程释放了锁，就不需要进行用户态到内核态的切换。虽然如此，但自旋需要**占用很多 CPU 的资源**（自行理解汽车空档疯狂踩油门）。如果另一个线程 一直不释放锁，难道它就在这一直空转下去吗？

当然不可能，JDK 1.7 之前是**普通自旋**，会设定一个最大的自旋次数，**默认是 10 次**，超过这个阈值就停止自旋。JDK 1.7 之后，引入了**适应性自旋**。简单来说就是：这次自旋获取到锁了，自旋的次数就会**增加**；这次自旋没拿到锁，自旋的次数就会**减少**。

![img](java_synchronized.assets/e6c9d24egy1h019opjylgj207n06fwei.jpg)

#### （4）重量级锁

![重量级锁](java_synchronized.assets/e6c9d24egy1h012lwj018j20p306at8t.jpg)

上面提到，试图抢占的线程自旋达到阈值，就会**停止自旋**，那么此时锁就会膨胀成**重量级锁**。当其膨胀成重量级锁后，其他竞争的线程进来就不会自旋了，而是直接**阻塞**等待，并且 Mark Word 中的内容会变成一个**监视器（monitor）对象**，用来统一管理排队的线程。

这个 monitor 对象，每个对象都会关联一个。monitor 对象本质上是一个同步机制，保证了同时只有一个线程能够进入临界区，在 HotSpot 的虚拟机中，是由 C++ 类 ObjectMonitor 实现的。

那么 monitor 对象具体是如何来管理线程的？接下来我们看几个 ObjectMonitor 类关键的属性：

- **ContentionQueue**：是个队列，所有竞争锁的线程都会**先进入**这个队列中，可以理解为线程的统一入口，进入的线程会阻塞。
- **EntryList**：ContentionQueue 中有资格的线程会被移动到这里，相当于进行一轮初筛，进入的线程会阻塞。
- **Owner**：拥有当前 monitor 对象的线程，即 —— 持有锁的那个线程。
- **OnDeck**：与 Owner 线程进行竞争的线程，同一时刻只会有一个 OnDeck 线程在竞争。
- **WaitSet**：当 Owner 线程调用 `wait() `方法被阻塞之后，会被放到这里。当其被唤醒之后，会重新进入 EntryList 当中，这个集合的线程都会阻塞。
- **Count**：用于实现可重入锁，synchronized 是可重入的。

### **对象体**

对象体包含了当前对象的字段和值，在业务中u l是较为核心的部分。

### **对齐字节**

就是单纯用于填充的字节，没有其他的业务含义。其目的是为了保证对象所占用的内存大小为 8 的倍数，因为HotSpot VM 的内存管理要求对象的起始地址必须是 8 的倍数。

## 锁升级

了解完 4 种锁状态之后，我们就可以整体的来看一下锁升级的过程了。

线程 A 进入 synchronized 开始抢锁，JVM 会判断当前是否是偏向锁的状态，如果是就会根据 Mark Word 中存储的线程 ID 来判断，当前线程 A 是否就是持有偏向锁的线程。如果是，则忽略 check，线程 A 直接执行临界区内的代码。

但如果 Mark Word 里的线程不是线程 A，就会通过自旋尝试获取锁，如果获取到了，就将 Mark Word 中的线程 ID 改为自己的；如果竞争失败，就会立马撤销偏向锁，膨胀为轻量级锁。

后续的竞争线程都会通过自旋来尝试获取锁，如果自旋成功那么锁的状态仍然是轻量级锁。然而如果竞争失败，锁会膨胀为重量级锁，后续等待的竞争的线程都会被阻塞。

![锁升级过程](java_synchronized.assets/e6c9d24egy1h01ktohqbej20wu0kxab3.jpg)

## EOF

其实偏向锁还有一个撤销的过程，也是有代价的，但相比于偏向锁带好的好处，是能够接受的。但我们这里重点的还是关注锁升级的具体逻辑和细节，关于锁升级的过程就聊到这里。



# synchronized, lock, ReentrantLock

> 　　如果你向一个变量写值，而这个变量接下来可能会被另一个线程所读取，或者你从一个变量读值，而它的值可能是前面由另一个线程写入的，此时你就必须使用同步。

- **sychronized**

　 Java语言的**关键字**，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码，它是在 **软件层面依赖JVM实现同步**。 　　 synchronized 方法或语句的使用提供了对与每个对象相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁。

> 　　通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。

　　synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能 执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行 状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）

> 

　　synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为　synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。

　　

　　解决synchronized 方法的缺陷

　　

> 通过 synchronized关键字来声明synchronized 块。

```
synchronized(lock) {
// 访问或修改被锁保护的共享状态
}
```

> 其中的代码必须获得对象 syncObject （类实例或类）的锁方能执行。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。

　　当两个并发线程访问同一个对象中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

　　当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。其他线程对对象中所有其它synchronized(this)同步代码块的访问将被阻塞。

　　如果线程进入由线程已经拥有的监控器保护的 synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续） synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个 synchronized 块时，才释放锁。

　　在修饰代码块的时候需要一个reference对象作为锁的对象. 　　在修饰方法的时候默认是当前对象作为锁的对象. 　　在修饰类时候默认是当前类的Class对象作为锁的对象.

- **lock**

　　Lock 接口实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 Condition 对象。在硬件层面依赖特殊的CPU指令实现同步更加灵活。

> 什么是Condition ？ Condition 接口将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。

　　虽然 synchronized 方法和语句的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但有时也需要以更为灵活的方式使用锁。例如，某些遍历并发访问的数据结果的算法要求使用 "hand-over-hand" 或 "chain locking"：获取节点 A 的锁，然后再获取节点 B 的锁，然后释放 A 并获取 C，然后释放 B 并获取 D，依此类推。Lock 接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁，从而支持使用这种技术。

　　随着灵活性的增加，也带来了更多的责任。不使用块结构锁就失去了使用 synchronized 方法和语句时会出现的锁自动释放功能。在大多数情况下，应该使用以下语句：

```
　　　Lock l = ...; //lock接口的实现类对象
     l.lock();
     try {
         // access the resource protected by this lock
     } finally {
         l.unlock();
     }
```

在java.util.concurrent.locks包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock）.它们是具体实现类，不是java语言关键字。

- 

**ReentrantLock**

　　一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的**隐式监视器锁**相同的一些基本行为和语义，但功能更强大。

　　最典型的代码如下： 　　

```
 class X {
   private final ReentrantLock lock = new ReentrantLock();
   // ...

   public void m() { 
     lock.lock();  // block until condition holds
     try {
       // ... method body
     } finally {
       lock.unlock()
     }
   }
 }
```

> 重入性：指的是同一个线程多次试图获取它所占有的锁，请求会成功。当释放锁的时候，直到重入次数清零，锁才释放完毕。

　　ReentrantLock 的lock机制有2种，**忽略中断锁**和**响应中断锁**，这给我们带来了很大的灵活性。比如：如果A、B 2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是 一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock 不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；第二，B线程中断自己（或者别的线程中断它），ReentrantLock 处理了这个中断，并且不再等待这个锁的到来，完全放弃。 　　

　　ReentrantLock相对于synchronized多了三个高级功能： 　　 　　①等待可中断 　　　　在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待. 　　　　

```
tryLock(long timeout, TimeUnit unit)
```

　　　②公平锁 　　　　按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.

```
new RenentrantLock(boolean fair)
```

　　公平锁和非公平锁。这2种机制的意思从字面上也能了解个大概：即对于多线程来说，公平锁会依赖线程进来的顺序，后进来的线程后获得锁。而非公平锁的意思就是后进来的锁也可以和前边等待锁的线程同时竞争锁资源。对于效率来讲，当然是非公平锁效率更高，因为公平锁还要判断是不是线程队列的第一个才会让线程获得锁。 　　 　　③绑定多个Condition 　　　通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await(),signal();

- **synchronized和lock的用法与区别**  　synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。 　 　synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。　 　 　Lock用的是乐观锁方式。每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。

　ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错。

　ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。

　synchronized的话，锁的范围是整个方法或synchronized块部分；而Lock因为是方法调用，可以跨方法，灵活性更大

　一般情况下都是用synchronized原语实现同步，除非下列情况使用ReentrantLock 　　　 　　　①某个线程在等待一个锁的控制权的这段时间需要中断 　　　②需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程 　　　 ③具有公平锁功能，每个到来的线程都将排队等候